\section{Categories}\label{sec:categories}

\subsection*{Functional}
Functional systems are defined as such by their significant focus on numerical calculations and/or algorithmic operations. They range from core data structures such those defined in the fundamental language definition for Java through to cryptography suites such as ‘Bouncy Castle’ and full 3D physics environments such as JBullet. Common to all of these is a need to process large amounts of data accurately and efficiently. The main challenge for testing these kinds of systems would be in taking into account the effect particular input values may have if they cause the software to fail or increase the worst case execution time.

\subsection*{Complex}
Complex systems include operating systems such as Linux and software platforms such as Java VM. They require large amounts of source code, so there can be an explosion in the number of paths that need to be explored during testing. Significant integration and system testing must be performed on the many module interfaces in the software. Complex systems are often composed of individual components that may have been used previously in other systems, but they al must be retested for the new environment. When the components have been bought-in rather than developed in-house, the source code might not be available for testing. There is also the problem of redundancy in integration testing when the same features are tested multiple times. These problems may reduce the efficiency of testing such systems and test suites should be designed to minimise this effect.

\subsection*{Open}
Open systems involve multiple parties, both internally and externally, accessing and utilising features of the software, potentially with very different goals. This presents dangers from attackers outside the system and the possibility of conflict between different modules inside. For this reason, it is important the software possesses fault tolerance abilities and is able to maintain both the confidentiality and integrity of its data. This is often achieved through cryptography techniques and tamper-resistant mechanisms. Examples include software that uses the client-server model such as the Apache and Jigsaw web servers and distributed software systems such as those based around grid computing. Many complex problems may arise from the heterogeneity of the languages, platforms and architectures, making it impractical to show the software is free from errors. Therefore, it is difficult to make accurate predictions as to the reliability of the software. When an error is found, it may be difficult to recreate the exact same complex environment in which it occurred. This makes testing such systems very challenging.

\subsection*{Progressive}
Progressive systems are used to maintain and develop some data source. Whilst the software is being executed, this data will be interpreted and added to in different ways. For example, file management systems or database managers such as JDBC or Apache Derby. Testing of these systems must be able to show that the software can start with the data source in any particular state and must leave it in a legal state. This can be difficult, as the data source may potentially be infinite, or at least bounded by the available memory. Typically, this can be addressed by dividing the data source into manageable sections, for example a byte stream

\subsection*{User}
Systems that are centred on user-interaction may use command-line, GUIs or even web-based interfaces such as Swing or SWT. The distinction between the user interface and its underlying program may become blurred when for example, the program causes unsolicited GUI events to occur. There are a large number of paths through the program to be tested because of the many ways of interface components may be manipulated and the order in which they are utilised may also have an affect. It is not just the functionality that needs to be tested either, as it is important that the user can understand how to cause the system to perform the desired tasks. There is a distinct human element involved and this raises the level of unpredictability. It is important to test the interface components separately and then ensure they work correctly when used in different programs.

\subsection*{Timed}
Finally, systems that require some real-time performance or take advantage of concurrency, for example RTSJ and Javolution, can also be difficult to test. Incorrect operation of the software may result in unexpected deadlock and race conditions that are difficult to avoid and expensive to analyse. Eytani et al point out that all new processors are multi-core, so this type of system is becoming increasingly common \cite{Eytani}. Only a few of the process interleavings will result in concurrent faults and unit testing performs a deterministic schedule, so bugs in real time systems are typically found during stress tests. When a fault is detected it can be difficult to recreate the same conditions under which it occurred. Therefore, time-based systems can be unpredictable and difficult to test.